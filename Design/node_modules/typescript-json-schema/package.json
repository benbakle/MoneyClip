{
  "_args": [
    [
      "typescript-json-schema@github:quicktype/typescript-json-schema#8ce897297cd101605a8f331e439e3281585ce12e",
      "C:\\dev\\MoneyClip\\Design\\node_modules\\quicktype"
    ]
  ],
  "_from": "quicktype/typescript-json-schema#8ce897297cd101605a8f331e439e3281585ce12e",
  "_id": "typescript-json-schema@0.31.0",
  "_inCache": true,
  "_location": "/typescript-json-schema",
  "_phantomChildren": {
    "decamelize": "1.2.0",
    "get-caller-file": "1.0.3",
    "get-stream": "3.0.0",
    "is-stream": "1.1.0",
    "jsonify": "0.0.0",
    "map-age-cleaner": "0.1.3",
    "mimic-fn": "1.2.0",
    "nice-try": "1.0.5",
    "npm-run-path": "2.0.2",
    "p-finally": "1.0.0",
    "p-is-promise": "1.1.0",
    "path-exists": "3.0.0",
    "path-key": "2.0.1",
    "require-directory": "2.1.1",
    "require-main-filename": "1.0.1",
    "semver": "5.6.0",
    "set-blocking": "2.0.0",
    "shebang-command": "1.2.0",
    "signal-exit": "3.0.2",
    "strip-eof": "1.0.0",
    "which": "1.3.1",
    "wrap-ansi": "2.1.0",
    "y18n": "3.2.1"
  },
  "_requested": {
    "hosted": {
      "directUrl": "https://raw.githubusercontent.com/quicktype/typescript-json-schema/8ce897297cd101605a8f331e439e3281585ce12e/package.json",
      "gitUrl": "git://github.com/quicktype/typescript-json-schema.git#8ce897297cd101605a8f331e439e3281585ce12e",
      "httpsUrl": "git+https://github.com/quicktype/typescript-json-schema.git#8ce897297cd101605a8f331e439e3281585ce12e",
      "shortcut": "github:quicktype/typescript-json-schema#8ce897297cd101605a8f331e439e3281585ce12e",
      "ssh": "git@github.com:quicktype/typescript-json-schema.git#8ce897297cd101605a8f331e439e3281585ce12e",
      "sshUrl": "git+ssh://git@github.com/quicktype/typescript-json-schema.git#8ce897297cd101605a8f331e439e3281585ce12e",
      "type": "github"
    },
    "name": "typescript-json-schema",
    "raw": "typescript-json-schema@github:quicktype/typescript-json-schema#8ce897297cd101605a8f331e439e3281585ce12e",
    "rawSpec": "github:quicktype/typescript-json-schema#8ce897297cd101605a8f331e439e3281585ce12e",
    "scope": null,
    "spec": "github:quicktype/typescript-json-schema#8ce897297cd101605a8f331e439e3281585ce12e",
    "type": "hosted"
  },
  "_requiredBy": [
    "/quicktype"
  ],
  "_resolved": "git://github.com/quicktype/typescript-json-schema.git#8ce897297cd101605a8f331e439e3281585ce12e",
  "_shasum": "e8ef311717fc17fa45337ac704f1c997161756ae",
  "_shrinkwrap": null,
  "_spec": "typescript-json-schema@github:quicktype/typescript-json-schema#8ce897297cd101605a8f331e439e3281585ce12e",
  "_where": "C:\\dev\\MoneyClip\\Design\\node_modules\\quicktype",
  "author": {
    "name": "Yousef El-Dardiry and Dominik Moritz"
  },
  "bin": {
    "typescript-json-schema": "./bin/typescript-json-schema"
  },
  "bugs": {
    "url": "https://github.com/YousefED/typescript-json-schema/issues"
  },
  "contributors": [
    {
      "name": "Yousef El-Dardiry",
      "email": "yousef@tweetbeam.com",
      "url": "http://www.twitter.com/yousefed"
    },
    {
      "name": "Dominik Moritz",
      "email": "domoritz@gmail.com",
      "url": "https://www.domoritz.de/"
    },
    {
      "name": "Vladimir Krivosheev",
      "email": "develar@gmail.com"
    },
    {
      "name": "Fabian Pirklbauer",
      "email": "hi@fabiandev.io"
    }
  ],
  "dependencies": {
    "glob": "~7.1.2",
    "json-stable-stringify": "^1.0.1",
    "typescript": "^3.0.1",
    "yargs": "^12.0.1"
  },
  "description": "typescript-json-schema generates JSON Schema files from your Typescript sources",
  "devDependencies": {
    "@types/assertion-error": "^1.1.0",
    "@types/chai": "^4.1.4",
    "@types/glob": "^5.0.35",
    "@types/json-stable-stringify": "^1.0.32",
    "@types/mocha": "^5.2.5",
    "@types/node": "^10.5.4",
    "ajv": "^6.5.2",
    "chai": "^4.1.2",
    "mocha": "^5.2.0",
    "source-map-support": "^0.5.6",
    "ts-node": "^7.0.0",
    "tslint": "^5.11.0"
  },
  "gitHead": "8ce897297cd101605a8f331e439e3281585ce12e",
  "homepage": "https://github.com/YousefED/typescript-json-schema#readme",
  "installable": true,
  "keywords": [
    "forms",
    "json",
    "jsonschema",
    "schema",
    "typescript"
  ],
  "licenses": [
    {
      "type": "Apache",
      "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
    }
  ],
  "main": "typescript-json-schema.js",
  "name": "typescript-json-schema",
  "optionalDependencies": {},
  "readme": "# typescript-json-schema\r\n\r\n[![npm version](https://img.shields.io/npm/v/typescript-json-schema.svg)](https://www.npmjs.com/package/typescript-json-schema) [![Build Status](https://travis-ci.org/YousefED/typescript-json-schema.svg?branch=master)](https://travis-ci.org/YousefED/typescript-json-schema)\r\n\r\nGenerate json-schemas from your Typescript sources.\r\n\r\n## Features\r\n\r\n* Compiles your Typescript program to get complete type information.\r\n* Translates required properties, extends, annotation keywords, property initializers as defaults. You can find examples for these features in the [test examples](https://github.com/YousefED/typescript-json-schema/tree/master/test/programs).\r\n\r\n## Usage\r\n\r\n### Command line\r\n\r\n* Install with `npm install typescript-json-schema -g`\r\n* Generate schema from a typescript type: `typescript-json-schema project/directory/tsconfig.json TYPE`\r\n\r\nTo generate files for only _some_ types in `tsconfig.json` specify\r\nfilenames or globs with the `--include` option. This is especially useful for large projects.\r\n\r\nIn case no `tsconfig.json` is available for your project, you can directly specify the .ts files (this in this case we use some built-in compiler presets):\r\n\r\n* Generate schema from a typescript type: `typescript-json-schema \"project/directory/**/*.ts\" TYPE`\r\n\r\nThe `TYPE` can either be a single, fully qualified type or `*` to generate the schema for all types. \r\n\r\n```\r\nUsage: typescript-json-schema <path-to-typescript-files-or-tsconfig> <type>\r\n\r\nOptions:\r\n  --refs                Create shared ref definitions.                               [boolean] [default: true]\r\n  --aliasRefs           Create shared ref definitions for the type aliases.          [boolean] [default: false]\r\n  --topRef              Create a top-level ref definition.                           [boolean] [default: false]\r\n  --titles              Creates titles in the output schema.                         [boolean] [default: false]\r\n  --defaultProps        Create default properties definitions.                       [boolean] [default: false]\r\n  --noExtraProps        Disable additional properties in objects by default.         [boolean] [default: false]\r\n  --propOrder           Create property order definitions.                           [boolean] [default: false]\r\n  --required            Create required array for non-optional properties.           [boolean] [default: false]\r\n  --strictNullChecks    Make values non-nullable by default.                         [boolean] [default: false]\r\n  --useTypeOfKeyword    Use `typeOf` keyword (https://goo.gl/DC6sni) for functions.  [boolean] [default: false]\r\n  --out, -o             The output file, defaults to using stdout\r\n  --validationKeywords  Provide additional validation keywords to include            [array]   [default: []]\r\n  --include             Further limit tsconfig to include only matching files        [array]   [default: []]\r\n  --ignoreErrors        Generate even if the program has errors.                     [boolean] [default: false]\r\n  --excludePrivate      Exclude private members from the schema                      [boolean] [default: false]\r\n  --uniqueNames         Use unique names for type symbols.                           [boolean] [default: false]\r\n  --rejectDateType      Rejects Date fields in type definitions.                     [boolean] [default: false]\r\n  --id                  Set schema id.                                               [string] [default: \"\"]\r\n```\r\n\r\n### Programmatic use\r\n\r\n```ts\r\nimport {resolve} from \"path\";\r\n\r\nimport * as TJS from \"typescript-json-schema\";\r\n\r\n// optionally pass argument to schema generator\r\nconst settings: TJS.PartialArgs = {\r\n    required: true\r\n};\r\n\r\n// optionally pass ts compiler options\r\nconst compilerOptions: TJS.CompilerOptions = {\r\n    strictNullChecks: true\r\n}\r\n\r\n// optionally pass a base path\r\nconst basePath = \"./my-dir\";\r\n\r\nconst program = TJS.getProgramFromFiles([resolve(\"my-file.ts\")], compilerOptions, basePath);\r\n\r\n// We can either get the schema for one file and one type...\r\nconst schema = TJS.generateSchema(program, \"MyType\", settings);\r\n\r\n\r\n// ... or a generator that lets us incrementally get more schemas\r\n\r\nconst generator = TJS.buildGenerator(program, settings);\r\n\r\n// all symbols\r\nconst symbols = generator.getUserSymbols();\r\n\r\n// Get symbols for different types from generator.\r\ngenerator.getSchemaForSymbol(\"MyType\");\r\ngenerator.getSchemaForSymbol(\"AnotherType\");\r\n```\r\n\r\n```ts\r\n// In larger projects type names may not be unique,\r\n// while unique names may be enabled.\r\nconst settings: TJS.PartialArgs = {\r\n    uniqueNames: true\r\n};\r\n\r\nconst generator = TJS.buildGenerator(program, settings);\r\n\r\n// A list of all types of a given name can then be retrieved.\r\nconst symbolList = generator.getSymbols(\"MyType\");\r\n\r\n// Choose the appropriate type, and continue with the symbol's unique name.\r\ngenerator.getSchemaForSymbol(symbolList[1].name);\r\n\r\n// Also it is possible to get a list of all symbols.\r\nconst fullSymbolList = generator.getSymbols();\r\n```\r\n\r\n`getSymbols('<SymbolName>')` and `getSymbols()` return an array of `SymbolRef`, which is of the following format:\r\n\r\n```ts\r\ntype SymbolRef = {\r\n  name: string;\r\n  typeName: string;\r\n  fullyQualifiedName: string;\r\n  symbol: ts.Symbol;\r\n};\r\n```\r\n\r\n`getUserSymbols` and `getMainFileSymbols` return an array of `string`.\r\n\r\n### Annotations\r\n\r\nThe schema generator converts annotations to JSON schema properties.\r\n\r\nFor example\r\n\r\n```ts\r\nexport interface Shape {\r\n    /**\r\n     * The size of the shape.\r\n     *\r\n     * @minimum 0\r\n     * @TJS-type integer\r\n     */\r\n    size: number;\r\n}\r\n```\r\n\r\nwill be translated to\r\n\r\n```json\r\n{\r\n    \"$ref\": \"#/definitions/Shape\",\r\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\r\n    \"definitions\": {\r\n        \"Shape\": {\r\n            \"properties\": {\r\n                \"size\": {\r\n                    \"description\": \"The size of the shape.\",\r\n                    \"minimum\": 0,\r\n                    \"type\": \"integer\"\r\n                }\r\n            },\r\n            \"type\": \"object\"\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nNote that we needed to use `@TJS-type` instead of just `@type` because of an [issue with the typescript compiler](https://github.com/Microsoft/TypeScript/issues/13498).\r\n\r\n## Background\r\n\r\nInspired and builds upon [Typson](https://github.com/lbovet/typson/), but typescript-json-schema is compatible with more recent Typescript versions. Also, since it uses the Typescript compiler internally, more advanced scenarios are possible.\r\n\r\n## Debugging\r\n\r\n`npm run debug -- test/programs/type-alias-single/main.ts --aliasRefs true MyString`\r\n\r\nAnd connect via the debugger protocol.\r\n\r\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/YousefED/typescript-json-schema.git"
  },
  "scripts": {
    "build": "tsc -p .",
    "debug": "ts-node --inspect=19248 --debug-brk typescript-json-schema-cli.ts",
    "lint": "tslint --project tsconfig.json -c tslint.json --exclude '**/*.d.ts'",
    "run": "ts-node typescript-json-schema-cli.ts",
    "test": "npm run build && mocha -t 5000 --require source-map-support/register test"
  },
  "typings": "typescript-json-schema.d.ts",
  "version": "0.31.0"
}
